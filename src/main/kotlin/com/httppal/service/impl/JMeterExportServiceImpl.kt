package com.httppal.service.impl

import com.httppal.model.*
import com.httppal.service.JMeterExportService
import java.io.File
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.*

/**
 * Implementation of JMeterExportService for exporting HTTP requests to JMeter .jmx format
 */
class JMeterExportServiceImpl : JMeterExportService {
    
    override fun exportSingleRequest(request: RequestConfig, environment: Environment?): JMeterTestPlan {
        val processedRequest = processRequestWithEnvironment(request, environment)
        
        val httpSampler = createHttpSampler(processedRequest, "HTTP Request")
        val threadGroup = JMeterThreadGroup(
            name = "Single Request Thread Group",
            threadCount = 1,
            rampUpPeriod = 1,
            loopCount = 1,
            httpSamplers = listOf(httpSampler)
        )
        
        return JMeterTestPlan(
            name = "Single Request Test Plan",
            threadGroups = listOf(threadGroup),
            globalHeaders = environment?.globalHeaders ?: emptyMap(),
            baseUrl = environment?.baseUrl
        )
    }
    
    override fun exportConcurrentScenario(
        request: RequestConfig, 
        threadCount: Int, 
        iterations: Int, 
        environment: Environment?
    ): JMeterTestPlan {
        require(threadCount > 0) { "Thread count must be positive" }
        require(iterations > 0) { "Iterations must be positive" }
        
        val processedRequest = processRequestWithEnvironment(request, environment)
        
        val httpSampler = createHttpSampler(processedRequest, "Concurrent Request")
        val threadGroup = JMeterThreadGroup(
            name = "Concurrent Execution Thread Group",
            threadCount = threadCount,
            rampUpPeriod = Math.max(1, threadCount / 10), // Ramp up over 10% of thread count seconds
            loopCount = iterations,
            httpSamplers = listOf(httpSampler)
        )
        
        return JMeterTestPlan(
            name = "Concurrent Execution Test Plan",
            threadGroups = listOf(threadGroup),
            globalHeaders = environment?.globalHeaders ?: emptyMap(),
            baseUrl = environment?.baseUrl,
            testPlanProperties = mapOf(
                "ThreadGroup.num_threads" to threadCount.toString(),
                "ThreadGroup.ramp_time" to (threadCount / 10).toString(),
                "LoopController.loops" to iterations.toString()
            )
        )
    }
    
    override fun exportMultipleRequests(requests: List<RequestConfig>, environment: Environment?): JMeterTestPlan {
        require(requests.isNotEmpty()) { "Request list cannot be empty" }
        
        val httpSamplers = requests.mapIndexed { index, request ->
            val processedRequest = processRequestWithEnvironment(request, environment)
            createHttpSampler(processedRequest, "Request ${index + 1}: ${request.method} ${extractPath(request.url)}")
        }
        
        val threadGroup = JMeterThreadGroup(
            name = "Multiple Requests Thread Group",
            threadCount = 1,
            rampUpPeriod = 1,
            loopCount = 1,
            httpSamplers = httpSamplers
        )
        
        return JMeterTestPlan(
            name = "Multiple Requests Test Plan",
            threadGroups = listOf(threadGroup),
            globalHeaders = environment?.globalHeaders ?: emptyMap(),
            baseUrl = environment?.baseUrl,
            testPlanProperties = mapOf(
                "TestPlan.comments" to "Generated from HttpPal Plugin - ${requests.size} requests"
            )
        )
    }
    
    override fun generateJmxFile(testPlan: JMeterTestPlan): String {
        val timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
        
        return buildString {
            appendLine("<?xml version=\"1.0\" encoding=\"UTF-8\"?>")
            appendLine("<jmeterTestPlan version=\"1.2\" properties=\"5.0\" jmeter=\"5.4.1\">")
            appendLine("  <hashTree>")
            
            // Test Plan element
            appendLine("    <TestPlan guiclass=\"TestPlanGui\" testclass=\"TestPlan\" testname=\"${escapeXml(testPlan.name)}\" enabled=\"true\">")
            appendLine("      <stringProp name=\"TestPlan.comments\">Generated by HttpPal Plugin on $timestamp</stringProp>")
            appendLine("      <boolProp name=\"TestPlan.functional_mode\">false</boolProp>")
            appendLine("      <boolProp name=\"TestPlan.tearDown_on_shutdown\">true</boolProp>")
            appendLine("      <boolProp name=\"TestPlan.serialize_threadgroups\">false</boolProp>")
            appendLine("      <elementProp name=\"TestPlan.arguments\" elementType=\"Arguments\" guiclass=\"ArgumentsPanel\" testclass=\"Arguments\" testname=\"User Defined Variables\" enabled=\"true\">")
            appendLine("        <collectionProp name=\"Arguments.arguments\">")
            
            // Add base URL as variable if present
            testPlan.baseUrl?.let { baseUrl ->
                appendLine("          <elementProp name=\"BASE_URL\" elementType=\"Argument\">")
                appendLine("            <stringProp name=\"Argument.name\">BASE_URL</stringProp>")
                appendLine("            <stringProp name=\"Argument.value\">${escapeXml(baseUrl)}</stringProp>")
                appendLine("            <stringProp name=\"Argument.metadata\">=</stringProp>")
                appendLine("          </elementProp>")
            }
            
            appendLine("        </collectionProp>")
            appendLine("      </elementProp>")
            appendLine("      <stringProp name=\"TestPlan.user_define_classpath\"></stringProp>")
            appendLine("    </TestPlan>")
            appendLine("    <hashTree>")
            
            // Global headers if present
            if (testPlan.globalHeaders.isNotEmpty()) {
                appendLine("      <HeaderManager guiclass=\"HeaderPanel\" testclass=\"HeaderManager\" testname=\"HTTP Header Manager\" enabled=\"true\">")
                appendLine("        <collectionProp name=\"HeaderManager.headers\">")
                testPlan.globalHeaders.forEach { (name, value) ->
                    appendLine("          <elementProp name=\"\" elementType=\"Header\">")
                    appendLine("            <stringProp name=\"Header.name\">${escapeXml(name)}</stringProp>")
                    appendLine("            <stringProp name=\"Header.value\">${escapeXml(value)}</stringProp>")
                    appendLine("          </elementProp>")
                }
                appendLine("        </collectionProp>")
                appendLine("      </HeaderManager>")
                appendLine("      <hashTree/>")
            }
            
            // Thread Groups
            testPlan.threadGroups.forEach { threadGroup ->
                generateThreadGroup(threadGroup, testPlan.baseUrl)
            }
            
            appendLine("    </hashTree>")
            appendLine("  </hashTree>")
            appendLine("</jmeterTestPlan>")
        }
    }
    
    override fun saveJmxFile(testPlan: JMeterTestPlan, filePath: String) {
        val jmxContent = generateJmxFile(testPlan)
        val file = File(filePath)
        
        // Ensure parent directories exist
        file.parentFile?.mkdirs()
        
        file.writeText(jmxContent, Charsets.UTF_8)
    }
    
    private fun processRequestWithEnvironment(request: RequestConfig, environment: Environment?): RequestConfig {
        return if (environment != null) {
            request.withEnvironment(environment)
        } else {
            request
        }
    }
    
    private fun createHttpSampler(request: RequestConfig, name: String): JMeterHttpSampler {
        val parameters = mutableListOf<JMeterParameter>()
        
        // Add query parameters
        request.queryParameters.forEach { (paramName, paramValue) ->
            parameters.add(JMeterParameter(paramName, paramValue, JMeterParameterType.QUERY))
        }
        
        // Add POST parameters if body contains form data
        if (request.method == HttpMethod.POST && request.getContentType()?.contains("application/x-www-form-urlencoded") == true) {
            request.body?.let { body ->
                parseFormData(body).forEach { (paramName, paramValue) ->
                    parameters.add(JMeterParameter(paramName, paramValue, JMeterParameterType.POST))
                }
            }
        }
        
        // Add basic response code assertion
        val assertions = listOf(
            JMeterAssertion(
                type = JMeterAssertionType.RESPONSE_CODE,
                pattern = "200",
                field = JMeterAssertionField.RESPONSE_CODE
            )
        )
        
        return JMeterHttpSampler(
            name = name,
            method = request.method,
            path = extractPath(request.url),
            headers = request.headers,
            body = if (request.hasBody() && request.getContentType()?.contains("application/x-www-form-urlencoded") != true) request.body else null,
            parameters = parameters,
            assertions = assertions
        )
    }
    
    private fun extractPath(url: String): String {
        return try {
            val urlObj = java.net.URL(url)
            val path = urlObj.path
            val query = urlObj.query
            if (query != null) "$path?$query" else path
        } catch (e: Exception) {
            // If not a full URL, assume it's already a path
            url
        }
    }
    
    private fun parseFormData(body: String): Map<String, String> {
        return body.split("&")
            .mapNotNull { pair ->
                val parts = pair.split("=", limit = 2)
                if (parts.size == 2) {
                    java.net.URLDecoder.decode(parts[0], "UTF-8") to java.net.URLDecoder.decode(parts[1], "UTF-8")
                } else null
            }
            .toMap()
    }
    
    private fun StringBuilder.generateThreadGroup(threadGroup: JMeterThreadGroup, baseUrl: String?) {
        appendLine("      <ThreadGroup guiclass=\"ThreadGroupGui\" testclass=\"ThreadGroup\" testname=\"${escapeXml(threadGroup.name)}\" enabled=\"true\">")
        appendLine("        <stringProp name=\"ThreadGroup.on_sample_error\">continue</stringProp>")
        appendLine("        <elementProp name=\"ThreadGroup.main_controller\" elementType=\"LoopController\" guiclass=\"LoopControlPanel\" testclass=\"LoopController\" testname=\"Loop Controller\" enabled=\"true\">")
        appendLine("          <boolProp name=\"LoopController.continue_forever\">false</boolProp>")
        appendLine("          <stringProp name=\"LoopController.loops\">${threadGroup.loopCount}</stringProp>")
        appendLine("        </elementProp>")
        appendLine("        <stringProp name=\"ThreadGroup.num_threads\">${threadGroup.threadCount}</stringProp>")
        appendLine("        <stringProp name=\"ThreadGroup.ramp_time\">${threadGroup.rampUpPeriod}</stringProp>")
        appendLine("        <boolProp name=\"ThreadGroup.scheduler\">false</boolProp>")
        appendLine("        <stringProp name=\"ThreadGroup.duration\"></stringProp>")
        appendLine("        <stringProp name=\"ThreadGroup.delay\"></stringProp>")
        appendLine("        <boolProp name=\"ThreadGroup.same_user_on_next_iteration\">true</boolProp>")
        appendLine("      </ThreadGroup>")
        appendLine("      <hashTree>")
        
        // HTTP Samplers
        threadGroup.httpSamplers.forEach { sampler ->
            generateHttpSampler(sampler, baseUrl)
        }
        
        appendLine("      </hashTree>")
    }
    
    private fun StringBuilder.generateHttpSampler(sampler: JMeterHttpSampler, baseUrl: String?) {
        val domain = baseUrl?.let { extractDomain(it) } ?: ""
        val port = baseUrl?.let { extractPort(it) } ?: ""
        val protocol = baseUrl?.let { extractProtocol(it) } ?: "https"
        
        appendLine("        <HTTPSamplerProxy guiclass=\"HttpTestSampleGui\" testclass=\"HTTPSamplerProxy\" testname=\"${escapeXml(sampler.name)}\" enabled=\"true\">")
        appendLine("          <elementProp name=\"HTTPsampler.Arguments\" elementType=\"Arguments\" guiclass=\"HTTPArgumentsPanel\" testclass=\"Arguments\" testname=\"User Defined Variables\" enabled=\"true\">")
        appendLine("            <collectionProp name=\"Arguments.arguments\">")
        
        // Add parameters
        sampler.parameters.forEach { param ->
            appendLine("              <elementProp name=\"${escapeXml(param.name)}\" elementType=\"HTTPArgument\">")
            appendLine("                <boolProp name=\"HTTPArgument.always_encode\">false</boolProp>")
            appendLine("                <stringProp name=\"Argument.value\">${escapeXml(param.value)}</stringProp>")
            appendLine("                <stringProp name=\"Argument.metadata\">=</stringProp>")
            appendLine("                <boolProp name=\"HTTPArgument.use_equals\">true</boolProp>")
            appendLine("                <stringProp name=\"Argument.name\">${escapeXml(param.name)}</stringProp>")
            appendLine("              </elementProp>")
        }
        
        appendLine("            </collectionProp>")
        appendLine("          </elementProp>")
        appendLine("          <stringProp name=\"HTTPSampler.domain\">$domain</stringProp>")
        appendLine("          <stringProp name=\"HTTPSampler.port\">$port</stringProp>")
        appendLine("          <stringProp name=\"HTTPSampler.protocol\">$protocol</stringProp>")
        appendLine("          <stringProp name=\"HTTPSampler.contentEncoding\"></stringProp>")
        appendLine("          <stringProp name=\"HTTPSampler.path\">${escapeXml(sampler.path)}</stringProp>")
        appendLine("          <stringProp name=\"HTTPSampler.method\">${sampler.method}</stringProp>")
        appendLine("          <boolProp name=\"HTTPSampler.follow_redirects\">true</boolProp>")
        appendLine("          <boolProp name=\"HTTPSampler.auto_redirects\">false</boolProp>")
        appendLine("          <boolProp name=\"HTTPSampler.use_keepalive\">true</boolProp>")
        appendLine("          <boolProp name=\"HTTPSampler.DO_MULTIPART_POST\">false</boolProp>")
        appendLine("          <stringProp name=\"HTTPSampler.embedded_url_re\"></stringProp>")
        appendLine("          <stringProp name=\"HTTPSampler.connect_timeout\"></stringProp>")
        appendLine("          <stringProp name=\"HTTPSampler.response_timeout\"></stringProp>")
        
        // Add body data if present
        sampler.body?.let { body ->
            appendLine("          <boolProp name=\"HTTPSampler.postBodyRaw\">true</boolProp>")
            appendLine("          <elementProp name=\"HTTPsampler.Arguments\" elementType=\"Arguments\">")
            appendLine("            <collectionProp name=\"Arguments.arguments\">")
            appendLine("              <elementProp name=\"\" elementType=\"HTTPArgument\">")
            appendLine("                <boolProp name=\"HTTPArgument.always_encode\">false</boolProp>")
            appendLine("                <stringProp name=\"Argument.value\">${escapeXml(body)}</stringProp>")
            appendLine("                <stringProp name=\"Argument.metadata\">=</stringProp>")
            appendLine("              </elementProp>")
            appendLine("            </collectionProp>")
            appendLine("          </elementProp>")
        }
        
        appendLine("        </HTTPSamplerProxy>")
        appendLine("        <hashTree>")
        
        // Add headers if present
        if (sampler.headers.isNotEmpty()) {
            appendLine("          <HeaderManager guiclass=\"HeaderPanel\" testclass=\"HeaderManager\" testname=\"HTTP Header Manager\" enabled=\"true\">")
            appendLine("            <collectionProp name=\"HeaderManager.headers\">")
            sampler.headers.forEach { (name, value) ->
                appendLine("              <elementProp name=\"\" elementType=\"Header\">")
                appendLine("                <stringProp name=\"Header.name\">${escapeXml(name)}</stringProp>")
                appendLine("                <stringProp name=\"Header.value\">${escapeXml(value)}</stringProp>")
                appendLine("              </elementProp>")
            }
            appendLine("            </collectionProp>")
            appendLine("          </HeaderManager>")
            appendLine("          <hashTree/>")
        }
        
        // Add assertions
        sampler.assertions.forEach { assertion ->
            appendLine("          <ResponseAssertion guiclass=\"AssertionGui\" testclass=\"ResponseAssertion\" testname=\"Response Assertion\" enabled=\"true\">")
            appendLine("            <collectionProp name=\"Asserion.test_strings\">")
            appendLine("              <stringProp name=\"${UUID.randomUUID()}\">${escapeXml(assertion.pattern)}</stringProp>")
            appendLine("            </collectionProp>")
            appendLine("            <stringProp name=\"Assertion.custom_message\"></stringProp>")
            appendLine("            <stringProp name=\"Assertion.test_field\">${getAssertionField(assertion.field)}</stringProp>")
            appendLine("            <boolProp name=\"Assertion.assume_success\">false</boolProp>")
            appendLine("            <intProp name=\"Assertion.test_type\">${getAssertionType(assertion.type)}</intProp>")
            appendLine("          </ResponseAssertion>")
            appendLine("          <hashTree/>")
        }
        
        appendLine("        </hashTree>")
    }
    
    private fun extractDomain(url: String): String {
        return try {
            java.net.URL(url).host
        } catch (e: Exception) {
            ""
        }
    }
    
    private fun extractPort(url: String): String {
        return try {
            val port = java.net.URL(url).port
            if (port == -1) "" else port.toString()
        } catch (e: Exception) {
            ""
        }
    }
    
    private fun extractProtocol(url: String): String {
        return try {
            java.net.URL(url).protocol
        } catch (e: Exception) {
            "https"
        }
    }
    
    private fun getAssertionField(field: JMeterAssertionField): String {
        return when (field) {
            JMeterAssertionField.RESPONSE_CODE -> "Assertion.response_code"
            JMeterAssertionField.RESPONSE_MESSAGE -> "Assertion.response_message"
            JMeterAssertionField.RESPONSE_DATA -> "Assertion.response_data"
            JMeterAssertionField.RESPONSE_HEADERS -> "Assertion.response_headers"
        }
    }
    
    private fun getAssertionType(type: JMeterAssertionType): Int {
        return when (type) {
            JMeterAssertionType.RESPONSE_CODE -> 8 // Contains
            JMeterAssertionType.RESPONSE_MESSAGE -> 8 // Contains
            JMeterAssertionType.RESPONSE_DATA -> 8 // Contains
        }
    }
    
    private fun escapeXml(text: String): String {
        return text
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&apos;")
    }
}